#ifndef DRAW_OVERRIDE_H
#define DRAW_OVERRIDE_H

#include <maya/M3dView.h>
#include <maya/MDrawRegistry.h>
#include <maya/MHWGeometry.h>
#include <maya/MHWGeometryUtilities.h>
#include <maya/MPxGeometryOverride.h>
#include <maya/MShaderManager.h>
#include <maya/MSharedPtr.h>
#include <maya/MUserData.h>
#include <maya/MViewport2Renderer.h>

#include "twistSplineNode.h"

static const MString WireframeItemName = "twistSplineWires";

/*
	Customized rendering logic of TwistSplineNodeNode

	This class is responsible for generating the geometry (vertex buffer) from
	the procedure geometry. Beside rendering, the functions for generating
	geometry is also a crucial part in Viewport Caching (in contrast with
	Evaluation Caching).
*/
class TwistSplineGeometryOverride : public MPxGeometryOverride {
   public:
	static MPxGeometryOverride* Creator(const MObject& obj) {
		return new TwistSplineGeometryOverride(obj);
	}
	~TwistSplineGeometryOverride() override;

	// Support configuration functions :
	MHWRender::DrawAPI supportedDrawAPIs() const override {
		return MHWRender::DrawAPI::kAllDevices;
	}
	bool supportsEvaluationManagerParallelUpdate() const override {
		return false;
	}
	/*
		Supporting Viewport Caching (VP2 Custom Caching)

		Viewport Cache for customize rendering nodes is caching the geometry
		data generated by MPxGeometryOverride::populateGeometry(). Like the
		graphics API, the geometry data is usually expressed in three different
		objects:
		- Vertex Buffer : Viewport Cache
		- Index Buffer : No cache, must be time-independent
		- Uniform Buffer : Evaluation Cache
		Currently, *only* Vertex Buffer can be cached in Viewport Cache and all
		the data in Uniform Buffer (shader parameters such as Color), must be
		stored in Evaluation Cache.

		Viewport Caching is helpful if you are generating the geometry data in
		CPU. For GPU generated geometry, the benefit is limited. To make the
		Viewport caching works properly the following constraints must be meet:
		- requiresUpdateRenderItems(path) always return 'false' in
		background-dg-context.
		- requiresGeometryUpdate() always return 'true' when restored from
		cache (if geometry is animated).
		- populateGeometry() should be context-safe
	*/
	bool supportsVP2CustomCaching() const override { return false; }

	/*
		Interaction with TwistSplineNode
		- This is the only method where you can call MPlug::getValue() or
		Mdatablock::inputValue()
		- This method can be empty (in EM modes), if you have setup the node
		correctly with Technique 1.
	*/
	void updateDG() override;
	// For the best practice, this method should contain no status data
	void cleanUp() override{};

	// Render item functions, only involved in foreground rendering, should
	// not affect VP2 Caching at all
	bool requiresUpdateRenderItems(const MDagPath& path) const override;
	void updateRenderItems(const MDagPath& path,
						   MRenderItemList& list) override{};
	bool hasUIDrawables() const override { return true; };
	void addUIDrawables(const MDagPath& path, MUIDrawManager& drawManager,
						const MFrameContext& frameContext) override;

	// Geometry update functions, major entry for support VP2 Custom Caching
	bool requiresGeometryUpdate() const override;
	bool isIndexingDirty(const MRenderItem& item) override {
		return false;
	}  // Viewport Caching does not support index buffer change (animated
	   // topology)
	void populateGeometry(const MGeometryRequirements& requirements,
						  const MRenderItemList& renderItems,
						  MGeometry& data) override;

	// Debugging functions
	bool traceCallSequence() const override;
	void handleTraceMessage(const MString& message) const override;

   private:
	TwistSplineGeometryOverride(const MObject& obj);
	/*
	To ensure the plugin works well with Viewport and Evaluation Caching
	we recommend to use a state-less MpxGeometryOverride:

	- Store all time-dependent data on the attributes of corresponding Maya
	node, instead of a data member in MpxGeometryOverride.
	- updateDG() pulls (evaluates) all the time-dependent data on node by
	"MDataBlock::inputValue()", but *not* store them in a data member of
	MPxGeometryOverride
	- Always access the time-dependent data by "MDataBlock::outputValue()"
	in the renderer

	Backgrounds of the recommendation:

	In this plugin example, we have 3 different pipeline stages involved:
		1. Node Evaluation
		2. Geometry Update (MPxGeometryOverride invocation)
		3. Rendering (Shader-pre-draw-callback invocation)

	With (Evaluation or Viewport) Caching, some surprising mixture of
	stages happen concurrently:

	- Foreground thread :
	MPxGeometryOverride -> Shader Callback -> (Rendering on frame 10)
	- Background thread :
	Node Evaluation -> MPxGeometryOverride -> (Viewport cache fill on frame 20)

	Accessing the same data directly cross stage boundaries can cause
	incorrect result or even crash Maya. Thus we must use different storage
	for each data in each DG context (frame). And a depend node's attribute
	are always isolated for different context.

	Beside, within the MPxGeometryOverride invocation stage, it is not
	always safe to access its data member : During Viewport Cache
	Restoration, requiresGeometryUpdate() is the only method get called.
	(No updateDG() call) Thus the data must be stored in the node.
	*/
	TwistSplineNode* mTwistSplineNode;	// The node we are rendering
};

#endif
